package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, CONST, CLASS, EXTENDS, ABSTRACT, VOID, BREAK, CONTINUE, READ, PRINT, RETURN, NEW, DOT;
terminal IF, ELSE, FOR;
terminal SEMI,  LBRACE, RBRACE, COMMA, ASSIGN, LSQPAREN, RSQPAREN, LPAREN, RPAREN;
terminal INC, DEC, PLUS, MINUS, AND, OR, MUL, DIV, MODUO, EQUAL, NEQUAL, GRT, GRTEQ, LST, LSTEQ;

terminal String IDENT;
terminal Integer NUMBER;
terminal Boolean BOOL; /*Boolean*/
terminal Character CHAR;

nonterminal Program, ProgName, ProgDeclList, MethodDeclList, ProgDeclPart;
nonterminal ConstDecl, VarDecl, AbstractClassDecl, ClassDecl, ConstList, ConstPart, MethodDecl;
nonterminal Type, ConstType;
nonterminal VarList, VarPart, VarDeclOpt;
nonterminal MethodDeclListOpt, ClassName, Extend;
nonterminal AbstractMethodList, AbstractClassMethods, AbsRegularMethod, AbstractMethodDecl;
nonterminal RetType, FormParsOpt, FormPars, StatementList, Statement, FormParsPart, FormParsList;
nonterminal DesignatorStatement, Condition, ElseOptStatement, DesignatorStmtOpt, ConditionOpt, RetVal, NumConstOpt, Designator;
nonterminal Expr, DesigOperation, ActParsOptional, ActPars, ConditionList, CondTerm, CondTermList, CondFact, ExprMinusPlus, ExprList;
nonterminal Term, Factor, ArrExprOpt, ActualParamList, DesignatorList, DesignatorPart;

nonterminal Assignop, Relop, Addop, Mulop;
//GRAMMAR

Program ::= (Program) PROG ProgName ProgDeclList LBRACE MethodDeclList RBRACE 
			;
ProgName ::= (ProgramName) IDENT:programName 
		;
	
ProgDeclList ::= (ProgramVarDeclList) ProgDeclList ProgDeclPart
			|
			(NoProgramVarDeclList) /*epsilon*/
			;
			
ProgDeclPart ::= (ProgDeclPartConst) ConstDecl
			|
			(ProgDeclPartVar) VarDecl
			|
			(ProgDeclPartAbstractClass)  AbstractClassDecl
			|
			(AbstractClassDeclClassDecl) ClassDecl
			;

ConstDecl ::= (ConstantDecl) CONST Type:constType ConstList SEMI
			;
Type ::= (TypeName) IDENT:t 
		;
			
ConstList ::= (Constants) ConstList COMMA ConstPart
			|
			(ConstListPart) ConstPart
			;
			
ConstPart ::= (ConstantPart) IDENT:constName ASSIGN ConstType
                ;

ConstType ::=  (CharacterConst) CHAR:character 
           |
          (NumberConst) NUMBER:num
          |
          (BooleanConst) BOOL:boolConst
          ;     
          
VarDecl ::= (VarDeclaration) Type:varType VarList SEMI
		;
		
VarList ::= (VaribleList) VarList COMMA VarPart
		|
		(VarListPart) VarPart
		;   
		
VarPart ::= (VariablePart) IDENT:varName
		|
		(VariablePartArr) IDENT:varName LSQPAREN RSQPAREN
		;
		
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl) /* epsilon */
					;

ClassDecl ::= (ClassDeclaration) CLASS ClassName Extend LBRACE VarDeclOpt MethodDeclListOpt  RBRACE
			;
			
ClassName ::=(ClassName) IDENT:className				
			;

Extend ::= (ExtendTerm) EXTENDS IDENT:baseClass
		|
		(NoExtend) /*epsilon*/
		;
		
VarDeclOpt ::= (VariablesList) VarDeclOpt VarDecl
			|
			(NoVariablesList) /* epsilon */
			;

MethodDeclListOpt ::= (ClassMethodDecl) LBRACE MethodDeclList RBRACE
						|
						(NoMethodDeclListOptional) /*epsilon*/
						;
						
						
AbstractClassDecl ::= (AbstractClassDeclaration) ABSTRACT CLASS ClassName Extend LBRACE VarDeclOpt AbstractClassMethods RBRACE
					;
AbstractClassMethods ::= (AbsClassMethodDecl) LBRACE AbstractMethodList RBRACE
						  |
						  (NoAbstractClassMethods) /*epsilon*/
						  ;
						  
AbstractMethodList ::= (AbstractMethodDeclList) AbstractMethodList AbsRegularMethod
					| 
					(NoAbstractMethodList) /*epsilon*/
					;
		
AbsRegularMethod ::= (RegularMethod) MethodDecl
					|
					(AbsMethod) AbstractMethodDecl
					;
					
MethodDecl ::= (MethodDeclaration) RetType IDENT:methodName LPAREN FormParsOpt RPAREN VarDeclOpt LBRACE StatementList RBRACE
			;

AbstractMethodDecl ::= (AbstractMethodDeclaration) ABSTRACT RetType IDENT:methodName LPAREN FormParsOpt RPAREN SEMI
					;
		
RetType ::= (VoidRetType) VOID
		|
		(TypeRetType) Type:retType
		;
		
FormParsOpt ::= (FormalParametersOpt) FormPars
			|
			(NoFormPars) /*epsilon*/
			;
			
StatementList ::= (Statements) StatementList Statement 
                 |
                (NoStatements) /*epsilon*/
                 ;	
                 
FormPars ::= (FormalPars) FormParsList
			;
			
FormParsList ::= (FormalParamsList) FormParsList COMMA FormParsPart
				|
				(FormalParamsListPart) 	FormParsPart
				;

FormParsPart ::= (FormalParsPart) Type:fparType IDENT:fparName
			| 
			(FormParsPartSqParent) Type:fparType IDENT:fparName LSQPAREN RSQPAREN
				;

Statement ::= (DesignatorStatementStatement) DesignatorStatement SEMI
			|
			(IfStatement) IF LPAREN Condition RPAREN ElseOptStatement
			|
			(ForStatement) FOR LPAREN DesignatorStmtOpt SEMI ConditionOpt SEMI DesignatorStmtOpt RPAREN Statement
			|
			(BreakStatement) BREAK SEMI
			|
			(ContinueStatement) CONTINUE SEMI
			|
			(ReturnStatement) RETURN RetVal SEMI
			|
			(ReadStatement) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStatement) PRINT LPAREN Expr NumConstOpt RPAREN SEMI
			|
			(StatmentBrace)LBRACE StatementList RBRACE
			;
			
RetVal ::= (RetValue) Expr:retVal
		|
		(NoRetVal) /*epsilon*/
		;		
			
NumConstOpt ::= (PrintNumConstOpt) COMMA NUMBER
				  |
				  (NoNumConstOpt) /*epsilon*/
				  ;
ElseOptStatement ::= (ElseStatement) ELSE Statement
					|
					(NoElseStatement) /*epsilon*/
					;
					
DesignatorStmtOpt ::= (OptionalDesignatorStmt) DesignatorStatement
					| 
					(NoDesignatorStmt) /*epsilon*/ 
					;
					
ConditionOpt ::= (OptionalCondition) Condition
					|
					(NoCondition) /* epsilon */
					;

DesignatorStatement ::= (DesignStatment) Designator DesigOperation ;


DesigOperation ::= (DesigOperationAss) Assignop Expr
					|
					(DesigOperationInc) INC
					|
					(DesigOperationDec) DEC
					|
					(DesigOperationActPar) LPAREN ActParsOptional RPAREN
					;
ActParsOptional ::= (ActualParsOptional) ActPars
				|
				(NoActParsOptional) /* epsilon */
				;		
				
Condition ::= (Conditions) ConditionList
			;

ConditionList ::= (ConditionsLisOR) ConditionList OR CondTerm
				|
				(SingleCondList) CondTerm
				;

CondTerm ::= (ConditionTerm) CondTermList 
			;

CondTermList ::= (ConditionTermList) CondTermList AND CondFact
			 | 
			 (ConditionTermListOne) CondFact
			 ;

CondFact ::= (CondFactExpr) Expr
		 |
		 (CondFactExprRelop) Expr Relop Expr 
		 ;	

Expr ::= (Expresion)  ExprMinusPlus ExprList
		;

ExprMinusPlus ::= (ExprMinus) MINUS Term
			|
			(ExprPlus) Term
			;

ExprList ::= (AddopExpr) ExprList Addop Term
			|
             (NoAddopExpr) /* epsilon */
               ; 

Term ::= (MulopTerm) Term Mulop Factor
		|
		 (FactorTerm) Factor
		;	
		
		
Factor ::= (DesignatorFactor) Designator:desig
			|
		   (FuncCallFactor) Designator:funcname LPAREN ActParsOptional RPAREN
		    |
		   (ParentFactor) LPAREN Designator RPAREN
			|
		   (NumFactor) NUMBER:fact
			|
		   (CharFactor) CHAR:fact
		    |
		   (BoolFactor) BOOL:fact
		    |
		   (NewTypeFactor) NEW Type ArrExprOpt
		   ;
		
ArrExprOpt ::= (ArrayExpr) LSQPAREN Expr RSQPAREN
			|
			(NoArrayExprOpt) /* epsilon */
			;
			
Assignop ::= (Assignoper) ASSIGN
		;

ActPars ::= (Actuals) ActualParamList 
		;
			   
ActualParamList ::= (ActualParametersList) ActualParamList COMMA Expr
					|
					(ActualParamExpr) Expr
					;

Designator ::= (Design) IDENT:name DesignatorList
			;



DesignatorList ::= (DesignList) DesignatorList DesignatorPart
                   |
                  (NoDesignList)
                   ;  
                   
                   
                            
DesignatorPart ::= (DotDesignPart) DOT IDENT:name 
                  |
                  (ArrayDesignPart)  LSQPAREN Expr RSQPAREN
                  ;


Relop ::= (EqualOp) EQUAL
         |
       (NotEqual)  NEQUAL
         |
       (GrtOp)  GRT
         |
       (GrteOp)  GRTEQ
         |
       (LessOp)  LST
         |
       (LesseOp)  LSTEQ
         ; 
         
Addop ::= (Addoper) PLUS 
		| 
		(Suboper) MINUS
		;
	
	
		
Mulop ::= (Muloper) MUL
		|
		(Divoper) DIV
		|
		(Modoper) MODUO
		;				  