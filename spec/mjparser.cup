

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;

import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

import rs.etf.pp1.symboltable.concepts.*;


parser code {:

   



	Logger log = Logger.getLogger(getClass());
   
   boolean errorDetected;
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


init with {:

   
	errorDetected = false;

	
	
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



//TERMINALS

terminal PROG, CONST, ABSTRACT, CLASS, EXTENDS, VOID, RETURN, READ, PRINT, NEW;
terminal LBRACE, RBRACE, SEMI, COMMA, ASSIGN, LPAREN, RPAREN, LSQPAREN, RSQPAREN, DOT;
terminal INC, DEC, MINUS,PLUS, MUL, DIV, MODUO;
terminal AND, OR, EQUAL, NEQUAL, GRT, GRTEQ, LST,LSTEQ;
terminal IF, FOR, ELSE, BREAK, CONTINUE;


terminal Integer NUMBER;
terminal Boolean BOOL; /*Boolean*/
terminal Character CHAR;
terminal String IDENT;


//NON TERMINALS

nonterminal Program, ProgName, Extend;
nonterminal ConstDecl, ConstList, ConstPart, ConstType;
nonterminal VarDeclList, VarDecl;
nonterminal AbstractClassDecl, ClassDecl, ClassName,AbsClassName;
nonterminal MethodDeclListOptional, MethodDeclList, AbstractClassMethods, AbstractMethodList, AbsRegularMethod;
nonterminal MethodDecl, AbstractMethodDecl, MethodTypeName;
nonterminal FormPars, FormalParamList, Type;
nonterminal Assignop, Addop, Mulop, Relop;
nonterminal StatementList, Statement, NumConstOpt, ElseOptStatement, OptDesignatorStmt, OptCondition;
nonterminal DesignatorStatement, DesigOperation, DesignatorList, DesignatorPart;
nonterminal Condition, ConditionList, CondTerm, CondTermList, CondFact;
nonterminal Expr, ExprList, Factor, ExprOpt;
nonterminal ActPars, ActualParamList;
nonterminal Designator, ActParsOptional;
nonterminal ProgDeclList,ProgDeclPart, MinusSign, Term;
nonterminal VarPart, VarList, FormParamMethod,RetVal, ExprMinusPlus;
// PRECEDENCE




//GRAMMAR
Program ::= (Prog) PROG ProgName ProgDeclList LBRACE MethodDeclList RBRACE 
			;

ProgName ::= (ProgramName) IDENT:programName 
			;

ProgDeclList ::= (ProgDeclarationList) ProgDeclList ProgDeclPart
				|
				(NoProgDeclLists) /*epsilon*/
				;

ProgDeclPart ::= (ProgDeclPartConst) ConstDecl
			|
			(ProgDeclPartVar) VarDecl
			|
			(ProgDeclPartAbstractClass) AbstractClassDecl
			|
			(ProgDeclPartClass) ClassDecl
			;		
			
ConstDecl ::= (ConstDeclaration) CONST Type:constT ConstList SEMI
			;


ConstList ::=  (Constants) ConstList COMMA ConstPart 
               |
             (ConstListPart)  ConstPart
              ;

ConstPart ::= (ConstantPart) IDENT:constName ASSIGN ConstType
                ;


ConstType ::=  (CharacterConst) CHAR:character 
           |
          (NumberConst) NUMBER:number
          |
          (BooleanConst) BOOL:bool
          ;  
VarList ::= (Variables) VarList COMMA VarPart
			|
			(VarListOne) VarPart
			;		
				
VarPart ::= (VarPartIdent) IDENT:varName
		|
		(VarPartArray) IDENT:arrName LSQPAREN RSQPAREN 
		;

VarDeclList ::= (VariablesList) VarDeclList VarDecl
			|
			(NoVarDeclList) /*epsilon*/
			;
			
VarDecl ::= (VarDeclaration) Type:varType VarList SEMI 
		;

ClassDecl ::=(ClassDeclaration) CLASS ClassName Extend LBRACE VarDeclList MethodDeclListOptional RBRACE 
		   ;


ClassName ::=(ClsName) IDENT:className				
			;
				
Extend ::= (Extends) EXTENDS IDENT:baseClass
		|
		(NoExtend) /*epsilon*/
		;

MethodDeclListOptional ::= (ClassMethodDecl) LBRACE MethodDeclList RBRACE
						|
						(NoMethodDeclListOptional) /*epsilon*/
						;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;
					
					
AbstractClassDecl ::= (AbstractClassDeclaration) ABSTRACT CLASS AbsClassName Extend LBRACE VarDeclList AbstractClassMethods RBRACE
					;
					
AbsClassName ::= (AbstractClassName) IDENT:aclassName 
			;
									
AbstractClassMethods ::= (AbsClassMethodDecl) LBRACE AbstractMethodList RBRACE
						  |
						  (NoAbstractClassMethods) /*epsilon*/
						  ;


AbstractMethodList ::= (AbstractMethodDeclList) AbstractMethodList AbsRegularMethod
					| 
					(NoAbstractMethodList) /*epsilon*/
					;
		
AbsRegularMethod ::= (RegularMethod) MethodDecl
					|
					(AbsMethod) AbstractMethodDecl
					;


MethodDecl ::= (MethodDeclaration) MethodTypeName LPAREN FormParamMethod RPAREN VarDeclList LBRACE StatementList RBRACE 
			   ;

AbstractMethodDecl ::= (AbstrMethodDecl) ABSTRACT MethodTypeName LPAREN FormParamMethod RPAREN SEMI
					;

MethodTypeName ::= (ReturnValMethodTypeName) Type:retType IDENT:methName
				|
				(VoidMethodTypeName) VOID:retTypr IDENT:methName
				;

FormParamMethod ::= (FormalParamMethods) FormalParamList
				|
				(NoFormParamMethod) /*epsilon*/
				;

FormalParamList ::= (FormalParameterList) FormalParamList COMMA FormPars
					|
					(SingleFormalParamDecl) FormPars
					;

					
FormPars ::= (FormalParams)  Type:fparType IDENT:fparName
				| 
				(FormalParamDeclSqParent) Type:fparType IDENT:fparName LSQPAREN RSQPAREN
				;

				  
Type ::= (TypeName) IDENT:typeName 
		;

StatementList ::= (Statements) StatementList Statement 
				|
				(NoStmt) /* epsilon */
				 ;
				 
Statement ::= (DesignatorStatementStatement) DesignatorStatement SEMI
  			|
			(IfStatement) IF LPAREN Condition RPAREN ElseOptStatement
			|
			(ForStatement) FOR LPAREN OptDesignatorStmt SEMI OptCondition SEMI OptDesignatorStmt RPAREN Statement
			|
			(BreakStatement) BREAK SEMI
			|
			(ContinueStatement) CONTINUE SEMI
			|
			(ReturnStatement) RETURN RetVal SEMI
			|
			(ReadStatement) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStatement) PRINT LPAREN Expr NumConstOpt RPAREN SEMI
			|
			(StatmentBrace)LBRACE StatementList RBRACE
			;
			
RetVal ::= (RetValue) Expr:retVal
		|
		(NoRetVal)/*epsilon*/
		;		
			
NumConstOpt ::= (PrintNumConstOpt) COMMA NUMBER
				  |
				  (NoNumConstOpt) /*epsilon*/
				  ;
				  
ElseOptStatement ::= (ElseStatement) ELSE Statement
					|
					(NoElseStatement) /*epsilon*/
					;
					
OptDesignatorStmt ::= (OptionalDesignatorStmt) DesignatorStatement
					| 
					(NoDesignatorStmt) /*epsilon*/ 
					;
					
OptCondition ::= (OptionalCondition) Condition
					|
					(NoCondition) /*epsilon*/
					;

DesignatorStatement ::= (DesignStatment) Designator DesigOperation ;


DesigOperation ::= (DesigOperationAss) Assignop Expr
					|
					(DesigOperationInc) INC
					|
					(DesigOperationDec) DEC
					|
					(DesigOperationActPar) LPAREN ActParsOptional RPAREN
					;


ActParsOptional ::= (ActualParsOptional) ActPars
				|
				(NoActParsOptional) /*epsilon*/
				;
				
Condition ::= (Conditions) ConditionList
			;

ConditionList ::= (ConditionsLisOR) ConditionList OR CondTerm
				|
				(SingleCondList) CondTerm
				;

CondTerm ::= (ConditionTerm) CondTermList 
			;

CondTermList ::= (ConditionTermList) CondTermList AND CondFact
			 | 
			 (ConditionTermListOne) CondFact /*epsilon*/
			 ;

CondFact ::= (CondFactExpr) Expr
		 |
		 (CondFactExprRelop) Expr Relop Expr 
		 ;

	  

Expr ::= (Expresion)  ExprMinusPlus ExprList
		;

ExprMinusPlus ::= (ExprMinus) MINUS Term
			|
			(ExprPlus) Term
			;
			
MinusSign ::= (Minus) MINUS ;

ExprList ::= (AddopExpr) ExprList Addop Term
			|
             (NoAddopExpr) /*epsilon*/
               ; 

Term ::= (MulopTerm) Term Mulop Factor
		|
		 (FactorTerm) Factor
		;


Factor ::= (DesignatorFactor) Designator:desig
			|
		   (FuncCallFactor) Designator:funcname LPAREN ActParsOptional RPAREN
		    |
		   (ParentFactor) LPAREN Designator RPAREN
			|
		   (NumFactor) NUMBER:fact
			|
		   (CharFactor) CHAR:fact
		    |
		   (BoolFactor) BOOL:fact
		    |
		   (NewTypeFactor) NEW Type ExprOpt
		   ;
		
ExprOpt ::= (ExpresOpt) LSQPAREN Expr RSQPAREN
			|
			(NoExprOpt) /*epsilon*/
			;
			
	
ActPars ::= (Actuals) ActualParamList 
		;
			   
ActualParamList ::= (ActualParametersList) ActualParamList COMMA Expr
					|
					(ActualParamExpr) Expr
					;
					
					
Designator ::= (Design) IDENT:name DesignatorList
			;



DesignatorList ::= (DesignList) DesignatorList DesignatorPart
                   |
                  (NoDesignList)
                   ;  
                   
                   
                            
DesignatorPart ::= (DotDesignPart) DOT IDENT:name 
                  |
                  (ArrayDesignPart)  LSQPAREN Expr RSQPAREN
                  ;

Assignop ::= (Assignoper) ASSIGN
		;

Relop ::= (Equal) EQUAL
         |
       (NotEqual)  NEQUAL
         |
       (Grt)  GRT
         |
       (Grte)  GRTEQ
         |
       (Less)  LST
         |
       (Lesse)  LSTEQ
         ; 
         
Addop ::= (Addoper) PLUS 
		| 
		(Suboper) MINUS
		;
	
	
		
Mulop ::= (Muloper) MUL
		|
		(Divoper) DIV
		|
		(Modoper) MODUO
		;



	